#design pattern reading

## 简单工厂模式/工厂/抽象工厂

工厂模式，调用方（客户端）不需要了解新建对象的细节，直接从工厂类中获取对象的模式。

简单工厂，只有一个工厂类，负责产出各种对象。

工厂方法模式，由多个工厂的实现类，每个类负责生产一种对象。

抽象工厂模式，工厂方法模式的每个实现都只负责一种对象，抽象工厂模式则是产生一系列不同类型对象的模式。例子，一个系统需要支持多种数据库，每个数据库都有多张表，那一个数据库就需要一个具体工厂，产生各种表的数据对象。进一步优化，用简单工厂来产生抽象工厂对象，可以简化代码中的new
具体工厂，减少修改数据库时的代码改动量。再进一步，简单工厂可以通过反射来去除switch/if语句，符合封闭原则。新增抽象工厂时，就不需要修改简单工厂代码了。

区别：增加对象类型的情况下，简单工厂需要直接修改工厂类，改动对客户端透明。抽象工厂需要新实现一种工厂类，客户端需要知道有新的工厂实现类，才能使用。

好处：简单工厂，隐藏了新建对象的细节，尤其是对象构造非常复杂并且多变的情况。对象的改动，可以尽量避免客户端的改动。

抽象工厂同样隐藏细节，在新增对象类型的时候，在客户端角度，可以一定程度上减少重复代码。例如，简单工厂产生5个相同类型的对象，有5句重复的语句，如果要改动，就需要同时修改这5处调用的参数，如果是抽象工厂，只需要修改获取工厂实现类的语句。

## 原型模式

复用已有对象的值，减少新建对象时，繁琐的赋值各个域的操作。例如，一个100个域的对象，我们需要一个仅有1个域不同的新对象，就可以使用原型模式clone原对象，并且修改目标域。具体细节涉及了深拷贝和浅拷贝的区别。

## 代理模式

client通过代理访问真实对象的方法。proxyObject,
realObject继承同一个接口，proxyObject是client直接接触的对象，在proxyObject里有一个realObject的实例，proxyObject.method（）
一般会最终调用realObject的相同方法，此外可以添加一些额外逻辑。

## 装饰器模式

A impl baseInterface
B impl baseInterface
C impl baseInterface
D impl baseInterface

A a; B b; C c; D d;
d.decorate(c);
c.decorate(b);
b.decorate(a);

d.show(); --> d.show() -> c.show() --> b.show() --> a.show();

对于一个核心功能的层层包装，可以在不修改原有代码的情况下，添加新功能。装饰的顺序很重要。

## 依赖倒转原则

抽象不应该依赖细节，细节应该依赖抽象。
面向接口编程，而不是面向实现编程
里氏代换原则：子类可以替换父类，并且程序的行为不变

## 开放-封闭原则

对扩展开放，对修改封闭。
对简单工厂新增类型，就是不符合这个原则，因为需要对现有实现进行修改。抽象工厂模式，就符合：不对现有代码修改，而是通过实现新的子类来扩展。

## 外观模式 facade pattern

外观类对外服务，对client隐藏内部细节。外观类compose一系列内部的类。可以把复杂的内部关系封闭在facade类之内，client不需要关心。

## Builder模式

复杂的构造过程被封装成builder，client只需要new需要的builder，再调用director类的构造方法，传入builder就可以得到正确的对象。
builder子类需要实现builder接口，并实现所有需要实现的方法。client无需关心builder的实现细节。

## 状态模式

一个对象如果有很多状态，就会涉及状态的转换。状态的转换如果都写在同一个方法内，就会造成很冗长的方法。状态模式，就是把一个对象的各个状态抽出来成为独立的对象，每个状态维护自己的状态变化。这样状态的改变方式或者新增状态的需求，对代码的改动范围就会缩小到特定的一两个状态。（开放-封闭原则）

## 适配器模式

调用方和被调用方不完全兼容时，比如接口不兼容，需要一个中间媒介来沟通/翻译，否则需要修改双方的代码，违反了开放-封闭原则。client通过适配器来操作其他对象。在设计之初，就考虑了接口兼容问题，就可以避免这种问题，也就不需要适配器模式。

## 桥接模式

桥接模式，用组合（composition）或者聚合（aggregation）来替代继承或实现。避免继承，可以一定程度上减少需求变动带来的代码改动。oop建模时，有一些对象具有天然的继承特性，但有一些可以通过组合实现。比如手机壳，可以继承自手机组件，与屏幕平级。但手机壳跟手机本身并不是非常紧密联系的，所以也可以单独抽象出来，再组合进手机对象中。手机壳的改动就和手机本身的改动分离了。

## 观察者模式

双向耦合（表现为，两个对象中分别持有对方的实例）的代码，可以使用观察者模式，又叫发布-订阅模式



